/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { Suspense, useEffect, useRef, useState } from "react"
import { useCompoundBody } from "@react-three/cannon"
import { getDirectionOffset, usePlayerControls } from "./usePlayerControls"
import { useFrame, useThree } from "@react-three/fiber"
import { Group, Quaternion, Vector3 } from "three"
import { PerspectiveCamera, useGLTF } from "@react-three/drei"

export function Model(props: any) {
  const [ref, api] = useCompoundBody<any>(() => ({
    mass: 30,
    type: "Dynamic",
    position: [0, -5, 0],
    ...props,
    shapes: [
      { args: [1.5], position: [0, 4, 0], type: "Sphere" },
      { args: [1.5, 1.5, 2.5], position: [0, 2.2, 0], type: "Cylinder" },
      { args: [1.5], position: [0, 1.5, 0], type: "Sphere" },
    ],
  }))
  const { forward, backward, left, right, sprint, jump } = usePlayerControls()

  const { nodes, materials } = useGLTF("/test.glb")

  const group = useRef<Group>(null)
  const { camera, mouse } = useThree()
  const rotateAngleFrontAxis = new Vector3(0, 1, 0)
  const rotateAngleSideAxis = new Vector3(0, 0, 0)
  const rotateQuarternion = new Quaternion()
  const walkDirection = new Vector3()

  const speed = sprint ? 50 : 40
  const [fov, setFov] = useState(50)
  const cameraRef = useRef()

  const velocity = useRef([0, 0, 0])
  const angularVelocity = useRef([0, 0, 0])

  useEffect(() => {
    api.velocity.subscribe((v) => (velocity.current = v))
    api.angularVelocity.subscribe((av) => (angularVelocity.current = av))
  }, [])

  useFrame(() => {
    if (forward && fov <= 60) {
      setFov(fov + 0.25)
    } else if (backward && fov >= 40) {
      setFov(fov - 0.25)
    } else if (forward === false && backward === false) {
      if (fov < 50) {
        setFov(fov + 0.25)
      } else if (fov > 50) {
        setFov(fov - 0.25)
      }
    }

    if (jump && Math.abs(velocity.current[1]) < 0.01) {
      api.velocity.set(velocity.current[0], 10, velocity.current[2])
    }
    if (forward || backward || left || right) {
      const directionOffset = getDirectionOffset({
        w: forward,
        s: backward,
        d: right,
        a: left,
      })

      camera.getWorldDirection(walkDirection)
      walkDirection.y = 0

      walkDirection.applyAxisAngle(
        forward || backward ? rotateAngleFrontAxis : rotateAngleSideAxis,
        directionOffset
      )

      walkDirection.normalize().multiplyScalar(speed)

      const moveX = walkDirection.x
      const rotateY = right ? -Math.PI : left ? Math.PI : 0
      const moveZ = walkDirection.z

      if (forward || backward) {
        // rotateQuarternion.setFromAxisAngle(
        //   rotateAngleFrontAxis,
        //   directionOffset
        // )
        group.current?.quaternion.rotateTowards(rotateQuarternion, 0.2)

        api.velocity.set(moveX, 0, moveZ)
        api.angularVelocity.set(0, rotateY / 2, 0)
      } else {
        api.velocity.set(0, 0, moveZ)
        api.angularVelocity.set(0, rotateY, 0)
      }
    } else {
      api.angularVelocity.set(0, 0, 0)
    }
  })

  return (
    <Suspense fallback={null}>
      <group ref={ref}>
        <PerspectiveCamera
          ref={cameraRef}
          makeDefault
          position={[0, 16, -25]}
          rotation={[0.25, 3.15, 0]}
          fov={fov}
          onUpdate={(c) => c.updateProjectionMatrix()}
        />
        <group ref={group} scale={[5, 5, 5]} {...props} dispose={null}>
          <group>
            <primitive object={nodes.DeformationSystem1} />
            <primitive object={nodes.DeformationSystem} />
            <skinnedMesh
              name="Wea_NEKO_LightningWhip_01"
              geometry={(nodes.Wea_NEKO_LightningWhip_01 as any).geometry}
              material={materials.mtl_Wea_NEKO_LightningWhip_06}
              skeleton={(nodes.Wea_NEKO_LightningWhip_01 as any).skeleton}
            />
            <skinnedMesh
              name="NEKO_CatInAShell_Accessories"
              geometry={(nodes.NEKO_CatInAShell_Accessories as any).geometry}
              material={materials.mtl_NEKO_CatInAShell_Accessories}
              skeleton={(nodes.NEKO_CatInAShell_Accessories as any).skeleton}
            />
            <group name="NEKO_CatInAShell_Cloth">
              <skinnedMesh
                name="NEKO_CatInAShell_Cloth_1"
                geometry={(nodes.NEKO_CatInAShell_Cloth_1 as any).geometry}
                material={materials.mtl_NEKO_CatInAShell_Cloth}
                skeleton={(nodes.NEKO_CatInAShell_Cloth_1 as any).skeleton}
              />
              <skinnedMesh
                name="NEKO_CatInAShell_Cloth_2"
                geometry={(nodes.NEKO_CatInAShell_Cloth_2 as any).geometry}
                material={materials.mtl_NEKO_Top}
                skeleton={(nodes.NEKO_CatInAShell_Cloth_2 as any).skeleton}
              />
            </group>
            <skinnedMesh
              name="NEKO_CatInAShell_Hand"
              geometry={(nodes.NEKO_CatInAShell_Hand as any).geometry}
              material={materials.mtl_NEKO_CatInAShell_Hand}
              skeleton={(nodes.NEKO_CatInAShell_Hand as any).skeleton}
            />
            <skinnedMesh
              name="NEKO_CatInAShell_Shoes"
              geometry={(nodes.NEKO_CatInAShell_Shoes as any).geometry}
              material={materials.mtl_NEKO_CatInAShell_Shoes}
              skeleton={(nodes.NEKO_CatInAShell_Shoes as any).skeleton}
            />
            <skinnedMesh
              name="NEKO_CatInAShell_Pant"
              geometry={(nodes.NEKO_CatInAShell_Pant as any).geometry}
              material={materials.mtl_NEKO_CatInAShell_Pant}
              skeleton={(nodes.NEKO_CatInAShell_Pant as any).skeleton}
            />
            <group name="NEKO_Subrace_Crystalist_Head">
              <skinnedMesh
                name="NEKO_Subrace_Crystalist_Head_1"
                geometry={
                  (nodes.NEKO_Subrace_Crystalist_Head_1 as any).geometry
                }
                material={materials.mtl_NEKO_Subrace_Crystalist_Head}
                skeleton={
                  (nodes.NEKO_Subrace_Crystalist_Head_1 as any).skeleton
                }
              />
              <skinnedMesh
                name="NEKO_Subrace_Crystalist_Head_2"
                geometry={
                  (nodes.NEKO_Subrace_Crystalist_Head_2 as any).geometry
                }
                material={materials.mtl_NEKO_Subrace_eyes}
                skeleton={
                  (nodes.NEKO_Subrace_Crystalist_Head_2 as any).skeleton
                }
              />
            </group>
          </group>
        </group>
      </group>
    </Suspense>
  )
}

useGLTF.preload("/test.glb")
